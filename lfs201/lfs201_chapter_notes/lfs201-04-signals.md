Chapter 4: Signals
------------------

[4.2: Chatper 4 Introduction](#42-chatper-4-introduction)  
[4.3: Learning Objectives](#43-learning-objectives)  
[4.4: What Are Signals?](#44-what-are-signals?)  
[4.5: Types of Signals](#45-types-of-signals)  
[4.6: kill](#46-kill)  
[4.7: killall and pkill](#47-killall-and-pkill)  
[Lab 4.1: Examining Signal Priorities and Execution](#lab-41-examining-signal-priorities-and-execution)  
[Paths and Commands](#paths-and-commands)  
  
### 4.2: Chatper 4 Introduction
----
**signals** emit notifications between processes or from kernal to app
* one of the oldest forms of **inter-process communication (IPC)**
* used to signal when an action is completed or to terminate a process, for example
* the command for sending a signal is named "kill", but not all signals are kill signals

### 4.3: Learning Objectives
----
By the end of this chapter, you should be able to:
* Explain what signals are and how they are used.
* Know the different signals and types of signals available in Linux.
* Use kill, killall and pkill to send signals from the command line.

### 4.4: What Are Signals?
----
* **Signals** are one of the oldest methods of **Inter-Process Communication (IPC) and are used to notify processes about **asynchronous** events (or exceptions); by asynchronous, we mean the signal-receiving process may:
    * not expect the event to occur
    * expect the event, but not know when it is most likely to occur
* for example, if a user decides to terminate a running program, it could send a signal to the process through the kernel to interrupt and kill the process.  
* there are two pathy by which signals are sent to a process:
    * from the kernel to a user process, as a result of an exception or programming error
    * from a user process (using a system call) to the kernel which will then send it to a user process; the process sending the signal can be the same as the one receiving it
* signals can only be sent:
    * between processes owned by the same user
    * from a process ownded by the superuser to any process
* what the process does when receiving a signal depends on the way the program was written:
    * it can take actions to **handle** the signal
    * it can respond according to system defaults
    * **SIGKILL** and **SIGSTOP** cannot be handled and will always terminate the program

### 4.5: Types of Signals
----
* there are different types of signals, and the particular signal dispatched indicates the type of event that occurred; generally, signals handle two things:
    * exceptions detected by hardware (e.g. illegal memory reference)
    * exceptions generated by the environment (e.g. premature death of a process from user's terminal)
* use `$ kill -l` to see a list of signals with their numbers  
* the signals from **SIGRTMIN** (34) and on are called **real-time signals** and are arelatively recent addition
    * they have no predefined purpose
    * they can be queued up and are handled in a **FIFO** **F**irst **I**n **F**irst **O**ut) order
* the meaning attached to the signal type indicates what event caused the signal to be sent
* type `$ man 7 signal` for documentation

### 4.6: kill
----
* a process cannot send a signal directly to another process; it must ask the kernel to send the signal by executing a **system call**
* users, including the superuser, can send signals to process by using **kill**:
    * `$ kill 1991` (PID = 1991; will send a **SIGTERM (15)** by default, which can be handled; program can take elusive action or clean up after itself rather than die immediately)
    * `$ kill -9 1991` (**SIGKILL (9)** cannot be ignored, causes termination with extreme prejudice)
    * `$ kill -SIGKILL 1991`
* **kill** is a misnomer b/c it is used to send any and all signals, even benign, informative ones
* passing **kill -SIGTSTP** or pressing **Ctrl+Z** do the same thing

### 4.7: killall and pkill
----
* **killall** kills all processes with a given name; uses a command name rather than PID:
    * `$ killall bash`
    * `$ killall -9 bash`
    * `$ killall -SIGKILL bash`
* **pkill** sends a signal to a process using selection criteria
    * `$ pkill [-signal] [options] [pattern]`
    * `$ pkill -u libby foobar` (will kill all of **libby**'s processes with a name of **foobar**)
    * `$ pkill -HUP rsyslogd` (makes **rsyslog** re-read its config file)

### Lab 4.1: Examining Signal Priorities and Execution
----
When run, the signals program:
* Does not send the signals SIGKILL or SIGSTOP, which can not be handled and will always terminate a program.
* Stores the sequence of signals as they come in, and updates a counter array for each signal that indicates how many times the signal has been handled.
* Begins by suspending processing of all signals and then installs a new set of signal handlers for all signals.
* Sends every possible signal to itself multiple times and then unblocks signal handling and the queued up signal handlers will be called.
* Prints out statistics including:
    * The total number of times each signal was received.
    * The order in which the signals were received, noting each time the total number of times that signal had been received up to that point.
Note the following:
* If more than one of a given signal is **raised** while the process has blocked it, does the process **receive** it multiple times? Does the behavior of **real time** signals differ from normal signals?
* Are all signals received by the process, or are some handled before they reach it?
* What order are the signals received in?
One signal, SIGCONT (18 on **x86**) may not get through; can you figure out why?  
Note:  
On some **Linux** distributions signals 32 and 33 can not be blocked and will cause the program to fail. Even though system header files indicate SIGRTMIN=32, the command kill -l indicates SIGRTMIN=34.
Note that **POSIX** says one should use signal names, not numbers, which are allowed to be completely implementation dependent. You should generally avoid sending these signals.

### Paths and Commands
----
  
#### Paths  

Topics | Path | Notes | Reference
------ | ---- | ----- | ---------
  
#### Commands  

Topics | Command | Notes | Reference
------ | ------- | ----- | ---------
signals | `$ kill -l` | shows a list of signals with their numbers | LFS201 4.5
documentation, signals | `$ man 7 signal` | documentation for signals | LFS201 4.5
signals | `$ kill 1991` | sends a **SIGTERM (15)** to PID 1991, which can be handled | LFS201 4.6 
signals | `$ kill -9 1991` | sends a **SIGKILL (9)** which cannot be ignored and causes termination with extreme prejudice | LFS201 4.6 
signals | `$ kill -SIGKILL 1991` | sends a **SIGKILL (9)** which cannot be ignored and causes termination with extreme prejudice | LFS201 4.6
signals | `$ kill ...` | used to send any all signals, even benign informative ones | LFS201 4.6
signals | `$ killall bash` | kills all processes with the name **bash** using command name instead of PID | LFS201 4.7
signals | `$ killall -9 bash` | kills all processes with the name **bash** | LFS201 4.7
signals | `$ killall -SIGKILL bash` | kills all processes with the name **bash** | LFS201 4.7
signals | `$ pkill [-signal] [options] [pattern]` | generic syntax; sends a signal to a process using selection criteria | LFS201 4.7
signals | `$ pkill -u libby foobar`| kill all of **libby**'s processes with a name of **foobar** | LFS201 4.7
signals | `$ pkill -HUP rsyslogd`| makes **rsyslog** re-read its config file  | LFS201 4.7
packages | `$ gcc -o signals signals.c` | compiles the signals.c source code | LFS201 Lab 4.1
